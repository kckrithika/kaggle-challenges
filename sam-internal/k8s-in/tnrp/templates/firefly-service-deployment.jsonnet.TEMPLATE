local madkub = (import "firefly_madkub.jsonnet") + { templateFileName:: std.thisFile };
local images = import "fireflyimages.jsonnet";
local configs = import "config.jsonnet";
local portconfigs = import "portconfig.jsonnet";
local envConfig = import "configs/firefly_service_conf.jsonnet";
{
  // Required arguments for this template
  serviceName:: error "serviceName must be specified",
  portAnnotations:: error "portAnnotations must be specified",
  portConfigs:: error "portConfigs must be specified",
  replicas:: error "Replicas must be specified",
  role:: error "Role must be specified for certificate generation",
  dockerImage:: error "dockerImage must be specified ",
  command:: error "command must be specified ",
  env:: error "env must be specified ",
  volumeMounts:: error "volumeMounts must be specified ",

  local configs = import "config.jsonnet",
  local firefly_feature_flags = import "firefly_feature_flags.jsonnet",

  // Only generate certs for customer vaults for PR and Package services
  local is_customer_certs_enabled = ($['serviceName'] == "firefly-pullrequest" ||
    $['serviceName'] == "firefly-package" ||
    $['serviceName'] == "firefly-pullrequest-fcp" ||
    $['serviceName'] == "firefly-pullrequest-fcp-test" ||
    $['serviceName'] == "firefly-package-fcp"||
    $['serviceName'] == "firefly-package-fcp-test" ||
    $['serviceName'] == "firefly-pullrequest-mdp" ||
    $['serviceName'] == "firefly-package-mdp"),

  local is_mdp_certs_enabled = ($['serviceName'] == "firefly-pullrequest-mdp" ||
    $['serviceName'] == "firefly-package-mdp"),

  serviceConf:: {},
  commonVolMounts:: [
    {
      name: "certs",
      mountPath: "/certs",
    },
    {
      name: "git-ssh-keys",
      mountPath: "/root/.ssh/",
    },
    {
      name: 'app-config-volume',
      mountPath: '/etc/firefly/config',
    },
  ],
  // arguments for template
  commonEnv:: [
    {
      name: "MY_NODE_NAME",
      valueFrom:
      {
        fieldRef: { fieldPath: "spec.nodeName", apiVersion: "v1" },
      },
    },
    {
      name: "MY_POD_NAME",
      valueFrom:
      {
        fieldRef: { fieldPath: "metadata.name", apiVersion: "v1" },
      },
    },
    {
      name: "MY_POD_IP",
      valueFrom:
      {
        fieldRef: { fieldPath: "status.podIP", apiVersion: "v1" },
      },
    },
    {
      name: 'MY_POD_NAMESPACE',
      valueFrom:
      {
        fieldRef: { fieldPath: 'metadata.namespace', apiVersion: "v1" },
      },
    },
    {
      name: 'MY_APP_NAME',
      valueFrom:
      {
        fieldRef: { fieldPath: 'metadata.labels[\'name\']', apiVersion: "v1" },
      },
    },
  ],

  local configmap = {
    apiVersion: 'v1',
    kind: 'ConfigMap',
    metadata: {
      name: std.join("-", [$.serviceName] + [if "repoName" in $.serviceConf then $.serviceConf.repoName] + ['configmap']),
      namespace: 'firefly',
      labels: {} + configs.ownerLabel.tnrp,
    },
    data: $.data,
  },

  local service = {
    kind: 'Service',
    apiVersion: 'v1',
    metadata: {
      name: std.join("-", [$.serviceName] + [if "repoName" in $.serviceConf then $.serviceConf.repoName] + ['service']),
      namespace: 'firefly',
      labels: {
        app: $.serviceName,
      } + configs.ownerLabel.tnrp,
      [if firefly_feature_flags.is_slb_enabled then "annotations"]: {
        "slb.sfdc.net/name": $.serviceName,
        "slb.sfdc.net/portconfigurations": std.toString(
            $.portAnnotations,
        ),
      },
    },
    spec: {
      type: if firefly_feature_flags.is_slb_enabled then 'NodePort' else 'LoadBalancer',
      ports: $.portConfigs,
      selector: {
         name: $.serviceName,
      },
    },
  },

  local deployment = configs.deploymentBase("tnrp") {
    metadata: {
      name: std.join("-", [$.serviceName] + [if "repoName" in $.serviceConf then $.serviceConf.repoName] + ['deployment']),
      namespace: "firefly",
      labels: {
        name: $.serviceName,
      } + configs.ownerLabel.tnrp,
    },
    spec+: {
      replicas: $.replicas,
      template: {
        metadata: {
          namespace: "firefly",
          name: std.join("-", [$.serviceName] + [if "repoName" in $.serviceConf then $.serviceConf.repoName] + ['deployment']),
          labels: {
            name: $.serviceName,
          } + configs.ownerLabel.tnrp,
          local certReqs = [
            {"name": "certs", "cert-type":"client", "kingdom":"prd", "role": $.role},
          ] + if is_customer_certs_enabled then [
            {"name": "customer-certs", "cert-type":"client", "kingdom":"prd", "role": $.role + ".customer"},
          ] else if is_mdp_certs_enabled then [
            {"name": "mdp-certs", "cert-type":"client", "kingdom":"prd", "role": $.role + ".mdp"},
          ] else [],
          annotations: {
            'madkub.sam.sfdc.net/allcerts': std.manifestJson({"certreqs" : certReqs}),
          },
        },
        spec: {
          initContainers: [
            madkub.madkubInitContainer() + if is_customer_certs_enabled then {
              args +: [
                "--cert-folders",
                "customer-certs:/customer-certs/",
              ],
              volumeMounts +: [
                {
                  mountPath: "/customer-certs/",
                  name: "customer-certs",
                },
              ],
            } else if is_mdp_certs_enabled then {
              args +: [
                "--cert-folders",
                "mdp-certs:/mdp-certs/",
              ],
              volumeMounts +: [
                {
                  mountPath: "/mdp-certs/",
                  name: "mdp-certs",
                },
              ],
            } else {},
          ],
          containers: [
            madkub.madkubRefreshContainer() + if is_customer_certs_enabled then {
              args +: [
                "--cert-folders",
                "customer-certs:/customer-certs/",
              ],
              volumeMounts +: [         
                {
                  mountPath: "/customer-certs/",
                  name: "customer-certs",
                },
              ],
            } else if is_mdp_certs_enabled then {
              args +: [
                "--cert-folders",
                "mdp-certs:/mdp-certs/",
              ],
              volumeMounts +: [         
                {
                  mountPath: "/mdp-certs/",
                  name: "mdp-certs",
                },
              ],
            } else {},
            {
              name: $.serviceName,
              image: $.dockerImage,
              command: $.command,
              imagePullPolicy: 'Always',
              env: $.env,
              ports: [
                {
                  name: "admin-port",
                  protocol: "TCP",
                  containerPort: $.serviceConf.healthPort,
                },
              ] + if std.length($.serviceConf.port) < 0 then [] else $.serviceConf.port,
              volumeMounts: $.volumeMounts,
              livenessProbe: {
                httpGet: {
                path: '/actuator',
                port: 'admin-port',
                },
                initialDelaySeconds: 30,
                timeoutSeconds: 30,
                periodSeconds: 30,
                successThreshold: 1,
                failureThreshold: 10,
              },
//              [if std.startsWith($.serviceName, "firefly-intake") then "readinessProbe"]: {
//                httpGet: {
//                path: '/actuator/health',
//                port: 'admin-port',
//                },
//                initialDelaySeconds: 30,
//                timeoutSeconds: 30,
//                periodSeconds: 60,
//                successThreshold: 1,
//                failureThreshold: 10,
//              },
            } + configs.ipAddressResourceRequest,
          ] + if $.serviceConf.dindEnabled == false then [] else [
            {
              name: "dind-daemon",
              image: images.fireflydind,
              securityContext: {
                privileged: true,
              },
              volumeMounts: [
                {
                  name: "docker-build-dir",
                  mountPath: "/tmp",
                },
                {
                  name: "git-ssh-keys",
                  mountPath: "/root/.ssh/",
                },
                {
                  name: "firefly-root-dir",
                  mountPath: "/firefly",
                },
                {
                  name: "customer-certs",
                  mountPath: "/customer-certs/",
                },
              ],
            },
          ],
          volumes: [
            {
              name: 'app-config-volume',
              projected: {
                sources: [
                  {
                    configMap: {
                      name: std.join("-", [$.serviceName] + [if "repoName" in $.serviceConf then $.serviceConf.repoName] + ['configmap']),
                      items: [
                        {
                          key: 'application.yml',
                          path: 'application.yml',
                        },
                      ],
                    },
                  },
                ],
              },
            },
            {
              name: "docker-build-dir",
              emptyDir: {},
            },
            {
              name: "firefly-root-dir",
              emptyDir: {},
            },
            {
              name: "tokens",
              emptyDir: {
                medium: "Memory",
              },
            },
            {
              name: "certs",
              emptyDir: {
                medium: "Memory",
              },
            },
            {
              name: "git-ssh-keys",
              emptyDir: {
                medium: "Memory",
              },
            },
            configs.maddog_cert_volume,
          ] + if is_customer_certs_enabled then [
              {
                name: "customer-certs",
                emptyDir: {
                  medium: "Memory",
                },
              },
          ] else if is_mdp_certs_enabled then [
              {
                name: "mdp-certs",
                emptyDir: {
                  medium: "Memory",
                },
              },
          ] else [],
          terminationGracePeriodSeconds: 10,
          nodeSelector: {
            pool: $.serviceConf.pool,
          },
        },
      },
      strategy: {
        type: "RollingUpdate",
        rollingUpdate: {
          maxUnavailable: 1,
          maxSurge: 0,
        },
      },
    },
  },

  apiVersion: 'v1',
  kind: 'List',
  items: [configmap, service, deployment],
}
