#!/bin/bash
#exit on error
set -e

REPO_OWNER=sam

locate_sam_binaries() {
    if [ -n "${FIREFLY}" ]; then
        SAMBINDIR=/sam
    elif [ -n "${LOCAL_SAM_BIN_PATH}" ]; then
        SAMBINDIR="${LOCAL_SAM_BIN_PATH}"
    else
        echo "No defined location for SAM binaries"
        exit 1
    fi
}

# Determine the path of tnrp/versions relative to the directory
# from which the tnrp/evaluate_pr script was called.
getSMBPackageName() {
    SCRIPT_DIR="${BASH_SOURCE%/*}"
    if [[ ! -d  "${SCRIPT_DIR}" ]]; then
        echo "${SCRIPT_DIR} is missing or not a directory."
        exit 1
    fi

    VERSIONS_SCRIPT="${SCRIPT_DIR}/versions"
    if [[ ! -f "${VERSIONS_SCRIPT}" ]]; then
        echo "${VERSIONS_SCRIPT} is missing or not a file."
        exit 1
    fi

    source "${VERSIONS_SCRIPT}"
    if [[ -z "${SMBPACKAGE}" ]]; then
        echo "SMBPACKAGE variable must be non-empty."
        exit 1
    fi
}

install_packages() {
    echo "Installing packages with: ${SMBPACKAGE}"
    yum install -y make gcc gcc-c++ "${SMBPACKAGE}"

    echo "Verifying package installed: ${SMBPACKAGE}"
    if ! yum list installed "${SMBPACKAGE}"; then
       echo "Expected package not installed: ${SMBPACKAGE}"
       exit 1
    fi
}

#exitIfMergeCommitFound checks if there are any
#merge commits introduced by the current branch
#which are not present in the origin/master.
#If it finds any merge commits, it calls exit.
exitIfMergeCommitFound() {
    GIT_CURRENT_BRANCH=$(git name-rev --name-only HEAD)
    tnrpBotName='tnrp-ro@salesforce.com'
    #Find count of all the merge commits that are
    #present in the current branch but not in origin/master.
    #Merge commits by tnrp bot are ignored.
    key="commit"
    mergeCommits=$(git log "origin/master..${GIT_CURRENT_BRANCH}" --merges --pretty=format:"$key %H %P %an" |grep -v $tnrpBotName | grep -c $key) || true
    #Find count of all non merge commits that are
    #present in the current branch but not in origin/master.
    #Commits by tnrp bot are ignored.
    nonMergeCommits=$(git log "origin/master..${GIT_CURRENT_BRANCH}" --no-merges --pretty=format:"$key %H %P %an" |grep -v $tnrpBotName | grep -c $key) || true
    echo "PR has ${mergeCommits} merge commits and ${nonMergeCommits} normal commits"
    if [ "$mergeCommits" -ne "0" ]
    then
        echo "Merge commits are not allowed in PRs"
        echo "For help removing them see http://stackoverflow.com/questions/21115596/remove-a-merge-commit-keeping-current-changes"
        exit 1
    fi
}

get_original_repo_contents() {
    echo -e "\ncloning repo: git.soma.salesforce.com:sam/${TNRP_PRODUCT}"
    rm -rf /tmp/manifests || true

    cd /tmp
    git clone "git@git.soma.salesforce.com:sam/${TNRP_PRODUCT}.git" manifests

    cd -
}

execute_aclrepo() {
    $SAMBINDIR/aclrepo -validateDir $PWD
}

ensure_git_personal_access_token() {
    if [ -n "$FIREFLY" ]; then
        # This is a temporary work-around while we wait for secret support in Firefly ~2/15.
        # This is a pgp encrypted read-only git token.  We use the md5 of the firefly ssh key to decrypt this at runtime.
        echo "jA0EBwMCePMTZtkaEHXW0mMBsHBfGssM0kNt8edebupSSPdtUSCrZaXv3u+qxw5lQ67p0SQmMYXxzG+chWx25dVVrzHQCAjcHhWO4d0cQLcmRUIhftd4/LZ+w0rq/BFAmK4MjzJm3om0BZFfrMQZqyUS/8w=" | base64 -d > token.txt.gpg
        gpg --yes --batch --passphrase=$(md5sum /root/.ssh/id_rsa | cut -f1 -d" ") ./token.txt.gpg &> /dev/nul
    else
        if [ ! -f "./token.txt" ]; then
            echo "ghe Personal Access token required"
            exit 1
        fi
    fi
}

ensure_gus_client_credentials() {
    if [ -n "$FIREFLY" ]; then
      # This is a temporary work-around while we wait for secret support in Firefly.
      # This is a pgp encrypted read-only git token.  We use the md5 of the firefly ssh key to decrypt this at runtime.

      # gus key
      echo "jA0EBwMCziL2J7zGzXPn0pYBqsxDW3w/6BaXFCBMVVHGYN4P7BynI4uXSnn2gPEqpelIBwp0HX+jkx8ZTsDlGx0E/TwjPcxpCNHaWFyYbVEkDCVX7eYx8KIOuFNBLKSqOcPbDnAelHG1hngDLoSxdFP9eK8/J53lR33V3cO0hSfOwn//FE6GC2QmR0PpFmxKVAnKwywEZcWYhy6RYdeJgW9yNQjZnnE=" | base64 -d > gus_key.txt.gpg
      gpg --yes --batch --passphrase=$(md5sum /root/.ssh/id_rsa | cut -f1 -d" ") ./gus_key.txt.gpg &> /dev/nul

      # gus secret
      echo "jA0EBwMCYPSBCiS9vKnn0oMBpzp6gucVR32D7ZHnzWTJBsyaYRLpIFwbo5Dgv18XbzFrWtIMjcD+fXM9lY1gnmNZtdmcdUMaCKAZhvmKC4+c+rUofo53Z9K/9+pmn2lW6iMwe8MvoHwQ2J6MsOFXszeUKq8AYBlq3oc/pdcFZiDV1cLJ2G8a9Ywf3J/m2vfr7HLqcQ==" | base64 -d > gus_secret.txt.gpg
      gpg --yes --batch --passphrase=$(md5sum /root/.ssh/id_rsa | cut -f1 -d" ") ./gus_secret.txt.gpg &> /dev/nul

      # gus username
      echo "jA0EBwMCNnlAuARB7wvr0lMBpbHfYIpZMAE5SemVyz7M8v+FymB35qwWjVcH4BtCGdYER2KSTMGsiKUBo+Gbh+hho0rcSeWylkECUPatE4IEAtWJgE8Y8OSsELHbLyZ5TcvUqg==" | base64 -d > gus_username.txt.gpg
      gpg --yes --batch --passphrase=$(md5sum /root/.ssh/id_rsa | cut -f1 -d" ") ./gus_username.txt.gpg &> /dev/nul

      # gus password
      echo "jA0EBwMC9jXX2r7hG6jr0moB/8ir8lMQ2Ns+9ZKDKuOZJ2rU5aLVbgwQKz8ouS9epoOi3j4+i5XF+Fq3gF2df9cWcWk680hKOQP3RW90we+TZ3Q+0tdIHZqlZTcC6ysO26gIEYFt5aoNSvjL2NWdpjhlmqjezSwJudrn" | base64 -d > gus_password.txt.gpg
      gpg --yes --batch --passphrase=$(md5sum /root/.ssh/id_rsa | cut -f1 -d" ") ./gus_password.txt.gpg &> /dev/nul
    else
      if [ ! -f "./gus_key.txt" ]; then
          echo "gus key required"
          exit 1
      fi
      if [ ! -f "./gus_secret.txt" ]; then
          echo "gus secret required"
          exit 1
      fi
      if [ ! -f "./gus_username.txt" ]; then
          echo "gus username required"
          exit 1
      fi
      if [ ! -f "./gus_password.txt" ]; then
          echo "gus password required"
          exit 1
      fi
    fi
}

execute_evaluate_pr() {
    IMAGE_EXISTS_TRIES=2
    EVAL_TIMEOUT=10m
    if [ -z "$FIREFLY" ]; then
        EXTRA_EVAL_FLAGS="-debug -logtostderr"
        IMAGE_EXISTS_TRIES=1
        EVAL_TIMEOUT=15m
    fi

    # For ops0-artifactrepo1-0-gcp and gcr.io in unvalidated-image-prefixes, it is a temp work-around to bypass image existence check during image promotion so that we can unblock customer PCN deployment
    # The reason we need two image prefixes here is that we have dual-run of both SMB and MANIFESTCTL:
    #  1)for SMB, though gcr images are valid long-form images, it is seen as short-form and get added prefix due to hard coded SMB function;
    #  2)for MANIFESTCTL, it is reserved in its original form
    $SAMBINDIR/evaluate-pr \
        --ghe-token-file ./token.txt \
        --self-authorize-dirs="xrd,prd,mvp,aws-us-east-2,aws-us-west-2" \
        -authorizer $STAGE_GO_TRIGGER_USER \
        -orig-dir /tmp/manifests \
        -dir-with-changes $PWD \
        -pr="$STAGE_PULL_REQUEST_ID" \
        -smb $SAMBINDIR/sam-manifest-builder \
        -repo-name="$TNRP_PRODUCT" \
        -unvalidated-image-prefixes "minikube,ops0-artifactrepo1-0-mvp,gcr.io,ops0-artifactrepo2-0-xrd.slb.sfdc.net,791719295754.dkr.ecr.us-east-2.amazonaws.com" \
        -full-schema \
        -image-exists-tries=${IMAGE_EXISTS_TRIES} \
        -image-exists-try-sleep-duration=10s \
        -validate-self-check-enabled=true \
        -self-authorize-check-regex="^(?:[^/]*/)sam-internal/k8s-out/([^/]*)/([^/]*)/,^(?:[^/]*/)apps/team/(?:[^/]*)/vips/" \
        --moratoriumEnabled=true \
        --maxNumberOfAdmins 2 \
        --moratoriumBegin="2019-11-27T00:01:00Z" \
        --moratoriumEnd="2019-12-03T08:00:00Z" \
        --imageRulePath="sam-internal/k8s-in/sam/configs/image-rules.json" \
        --MoratoriumAccessDisabledMessage="Moratorium is in effect.  See https://gus.lightning.force.com/lightning/r/0D5B000000yPf8vKAC/view  During the moratorium prod PRs require approval by an admin, and admins are required to ensure that changes properly follow the moratorium guidelines. For more information see http://sfdc.co/sam-admins." \
        --timeout=${EVAL_TIMEOUT} \
        --disableDedupFlag=false \
        --filenameRulePath=$PWD/sam-internal/k8s-in/sam/configs/filename-rules.json \
        ${EXTRA_EVAL_FLAGS} \

}

execute_validate_vips_yaml() {
    # Validate vips.yaml files for SLB, this does not copy any files to output
    echo -e "\n/opt/slb/slb-manifest-builder -root $PWD -output $PWD -validate --vcioptions.strict -v=1"
    /opt/slb/slb-manifest-builder -root $PWD -output $PWD -validate --vcioptions.strict -v=1
}

execute_post_merge_checks() {
    echo -e "\nSMB check complete, now run manifestctl (packaging) checks\n"

    if [ -z "$OUTPUT_DIR" ]; then
      OUTPUT_DIR=.
    fi

    $SAMBINDIR/manifestctl manifest-git-info --inputDir . -outputPath ${OUTPUT_DIR}/git-info.yaml -gitHistoryMode lib -alsologtostderr

    echo -e "\n"
    $SAMBINDIR/manifestctl build-repo -inputManifestDir . -outputDir ${OUTPUT_DIR} -alsologtostderr
}

if [ -n "$FIREFLY" ]; then
   echo "*** EXECUTING IN '$FIREFLY' ENVIRONMENT"
fi

locate_sam_binaries
getSMBPackageName
install_packages
exitIfMergeCommitFound
get_original_repo_contents

execute_aclrepo

ensure_git_personal_access_token
ensure_gus_client_credentials

execute_evaluate_pr
execute_validate_vips_yaml
execute_post_merge_checks
